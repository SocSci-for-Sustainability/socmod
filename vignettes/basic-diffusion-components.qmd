---
title: Building diffusion models with socmod
author: Matt Turner
vignette: >
  %\VignetteIndexEntry{Building diffusion models with socmod}
  %\VignetteEngine{quarto::quarto}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| include: false
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

```{r setup}
#| message: false
#| warning: false
library(socmod)
library(magrittr)
library(purrr)
library(dplyr)
```

Agent-based modeling (ABM) lets us encode rules of social behavior in software and
observe how those rules play out over time. `socmod` provides a tidy toolkit for
creating these simulations in R. This vignette introduces the building blocks you
will use when constructing diffusion models:

* The data structures and functional programming idioms that appear throughout
  `socmod`
* The object-oriented interface provided by [`R6`](https://r6.r-lib.org/)
* A small worked example that builds, runs, and visualizes a diffusion model

The goal is to make the package feel familiar so that you can dive into the other
articles—such as the companion pieces on [running diffusion experiments](diffusion-experiments.html)
and [working with empirical networks](empirical-networks.html)—with confidence.

## Working with data collections in R

Many `socmod` functions accept or return collections of data. Knowing how vectors,
lists, and tibbles behave will make it easier to chain analyses together using the
tidyverse.

### Basic data types

You will frequently interact with numeric and character data. The `typeof()`
function confirms what kind of object you are dealing with:

```{r}
typeof("c")
typeof("social science is kewl")
```

### Vectors

Vectors store values of a single type. R will coerce elements if necessary, so it
is good practice to keep them homogeneous:

```{r}
num_vec <- c(0, 0, 1)
num_vec
char_vec <- c("Legacy", "Adaptive")
char_vec
```

Index vectors with single square brackets. R is 1-indexed, so the first element is
at position 1:

```{r}
vec <- 1:5
vec[1]
vec[length(vec)]
```

### Lists and named lists

Lists can store heterogeneous objects, making them handy for `socmod` agents and
parameter bundles. Use double square brackets (`[[ ]]`) to retrieve individual
entries or `$` to access by name:

```{r}
agent_stats <- list(id = 1, name = "Alex", adopted = TRUE)
agent_stats[["name"]]
agent_stats$id
```

Subsetting with single square brackets returns a sub-list, which is useful when
you want to keep the list structure:

```{r}
agent_stats[c("id", "adopted")]
```

### Tibbles

Tibbles are tidyverse-friendly data frames. They print cleanly, avoid unexpected
type conversions, and work seamlessly with verbs like `dplyr::group_by()` and
`dplyr::summarise()`.

```{r}
observations <- tibble::tibble(
  condition = c("experimental", "experimental", "control", "control"),
  measurement = c(13.5, 14.6, 3.4, 5.4)
)
observations

observations %>%
  group_by(condition) %>%
  summarise(mean_measurement = mean(measurement))
```

## Functional programming idioms

`purrr` is part of the tidyverse and appears throughout `socmod`. It lets you pass
functions as inputs and iterate over data without writing explicit loops.

### Higher-order functions

A function that accepts another function as an argument is called *higher-order*.
This pattern lets you specify custom behavior succinctly.

```{r}
repeat_twice <- function(data, f) {
  c(f(data), f(data))
}

repeat_twice(2, function(x) x * 2)
```

### Mapping over collections

`purrr::map()` and its variants apply a function to every element of a collection.
Use `map_dbl()` (or `map_int()`, `map_chr()`, etc.) when you know the output type.

```{r}
purrr::map_dbl(c(2, 8), ~ 3 * .x)

input_vec <- c(2, 5050, 6)
purrr::imap_dbl(input_vec, ~ .y * .x)
```

## Encapsulating behavior with R6 classes

`socmod` represents agents and models with [`R6`](https://r6.r-lib.org/) classes.
These objects bundle state (fields) with behavior (methods) so that we can reason
about each agent or model as a coherent unit.

### Inspecting the built-in `Agent` class

Create a new agent by calling the constructor `Agent$new()` and then explore its
fields via accessor methods:

```{r}
a1 <- socmod::Agent$new(
  id = 1,
  name = "Casey",
  behavior = "Adaptive",
  fitness = 1.25
)

list(
  fitness = a1$get_fitness(),
  name = a1$get_name(),
  id = a1$get_id(),
  behavior = a1$get_behavior()
)
```

Agents maintain lists of neighbors. These lists are themselves R6 objects that
offer `map()` helpers so you can iterate over nearby agents without leaving the
object-oriented style.

```{r}
a1$set_neighbors(list(
  socmod::Agent$new(id = 2, name = "Jordan"),
  socmod::Agent$new(id = 3, name = "Riley")
))

neighbors <- a1$get_neighbors()
neighbors$map(function(nbr) nbr$get_name()) %>% unlist()
```

### Designing your own R6 classes

Defining new R6 classes can clarify your modeling ideas. The example below sketches
a minimal `Footballer` class with behavior stubs for scoring goals and drawing
penalties. Feel free to adapt this template when prototyping custom agent types.

```{r}
Footballer <- R6::R6Class(
  "Footballer",
  public = list(
    speed = 0.0,
    accuracy = 0.0,
    market_value = 0.0,
    aggressiveness = 0.0,
    team = "",

    initialize = function(speed = 15,
                          accuracy = 0.2,
                          market_value = 1e6,
                          aggressiveness = 0.5,
                          team = "Free agent") {
      self$speed <- speed
      self$accuracy <- accuracy
      self$market_value <- market_value
      self$aggressiveness <- aggressiveness
      self$team <- team
    },

    scored_goal = function() {
      as.integer(runif(1) < self$accuracy)
    },

    drew_penalty = function() {
      runif(1) < self$aggressiveness
    }
  )
)

Footballer$new(accuracy = 0.5)$scored_goal()
```

## Building a four-agent diffusion model

With the foundations in place we can assemble a simple diffusion model using
`socmod`'s helper functions. We will:

1. Create a small network and specify model parameters
2. Populate it with agents
3. Run a trial until the population fixates
4. Visualize the adoption dynamics

```{r}
set.seed(123)
g <- igraph::make_graph(~ 1-2, 1-3, 1-4, 3-2)
params <- socmod::make_model_parameters(
  learning_strategy = socmod::contagion_learning_strategy,
  graph = g,
  adoption_rate = 0.8,
  drop_rate = 0.1
)
model <- socmod::make_abm(params)

# Give agent 2 a head start with the adaptive behavior
model$get_agent(2)$set_behavior("Adaptive")
```

### Examine the initial state

`plot_network_adoption()` renders the network with node colors determined by each
agent's behavior.

```{r}
plot_network_adoption(model, layout = igraph::layout_in_circle, label = TRUE)
```

### Run the trial and collect observations

`run_trial()` iterates the model until every agent performs the same behavior. We
then summarize the prevalence of the adaptive behavior over time.

```{r}
trial <- socmod::run_trial(model, stop = socmod::fixated)
prevalence <- socmod::summarise_prevalence(trial)
head(prevalence)
```

### Visualize prevalence dynamics

Finally, plot the trajectory of the adaptive behavior. The color palette matches
`socmod` defaults, making it easy to compare figures across projects.

```{r}
plot_prevalence(trial, tracked_behaviors = c("Adaptive")) %>%
  { . + ggplot2::ggtitle("Adaptive fitness advantage = 0.8") }
```

## Where to go next

Now that you have seen the basic components, explore the other vignettes:

- [Running diffusion experiments](diffusion-experiments.html) shows how to sweep
  across parameter settings and analyse large collections of trials.
- [Working with empirical networks](empirical-networks.html) demonstrates how to
  import, inspect, and simulate on top of real social-network data.

Happy modeling!
